I"<p><span>AlwaysOn</span><br /><span>Always on feature provide high availability and disaster recovery solution. AlwaysOn maximizes the availability of a set of user databases for an enterprise and improve resource use. SQL Server 2012 provide option to make group set of database called Availability group which will be treated as individual entity.SQL Server 2012 can host multiple availability group. If any failover occur then flexibility to fail over one availability group to instance B, another availability group to instance C, and so on. we donâ€™t have to have a standby server that is capable of handling the full load of our primary server â€“ we can distribute those workloads across multiple, lower-powered servers. These new AlwaysOn features allow us much more power and flexibility in our efforts toward both high availability and disaster recovery, whether we are using Availability Groups or standard Failover Clustering.</span><br /><span>Contained Databases, which intends to reduce or eliminate the dependencies that a database has on the SQL Server instance, making it easier to migrate a database to a new instance with less of the work involved in reproducing and validating these dependencies.</span><br /><strong><span>ColumnStore Indexes</span></strong><br /><span>What a ColumnStore index does is essentially turn a traditional index on its side. Think about a covering index that includes multiple columns, but instead of storing all the different columns in a single row on a single page, split it up and store each column on its own set of pages. With certain types of queries, we experience drastically reduced I/O (even though it sounds like the index will span more pages, not less). Since each column is stored in its own set of pages, this makes compression much more effective.</span><br /><strong><span>TRY_CONVERT()</span></strong><br /><span>This function quite similar Â like convert function except it return null value if it canâ€™t convert any value instead of error code .</span><br /><span>SELECT CONVERT (INT, â€˜SSD-416.00â€™) Â </span><br /><span>Output display Error message but</span><br /><span>SELECT TRY_CONVERT (INT, â€˜SSD-416.00â€™) Â </span><br /><span>Output display NULL</span><br /><span>It will assist to reduce from unexpected termination from execution.</span><br /><strong><span>OFFSET / FETCH</span></strong><br /><span>Using this feature user can get the flavor or of paging , Offset indicate the initial value from where row will be display and fetch indicate number of rows will be fetch . Offset and fetch facilitate the scrolling data from table . It set after order by clause.</span><br /><span>Select * from Employee where departmentCode=â€™SSDâ€™ order by joiningdate Desc</span><br /><span>OFFSET 0 ROWS</span><br /><span>FETCH NEXT 10 ROWS ONLY</span><br /><strong><span>FORMAT()</span></strong><br /><span>SQL Server2012 introduce new date/time function ,using this user can easily generate various day format date, day name Â ,weekday Â etc.</span><br /><span>DECLARE @birthdate Â datetime = â€™2012-11-05â€™</span><br /><span>Select FORMAT (@birthdate Â ,Nâ€™dâ€™) [Date],</span><br /><span>Â Â Â Â Â  FORMAT (@birthdate Â ,Nâ€™ddâ€™) [Date],</span><br /><span>Â Â Â Â Â Â Â Â Â  FORMAT (@birthdate Â ,Nâ€™dddâ€™) [Date],</span><br /><span>Â Â Â Â Â Â Â Â Â  FORMAT (@birthdate Â ,Nâ€™ddddâ€™) [Date]</span><br /><span>Â </span><br /><span>Output</span><br /><span>11/05/2012Â Â  Â  05Â  Â Â Â Â Â  Thu Â Â Â Â  Thursday</span><br /><strong><span>Â </span></strong><br /><strong><span>EOMONTH </span></strong><br /><span>We have to face problem whenever we are going to identify the end date of month no built in function was there but now that problem has over in SQL Server 2012, EOMONTH return the date of the month</span><br /><span>SELECT EOMONTH (â€˜05/02/2012â€™) â€˜EOM Processing Date</span><br /><span>Output: 2012-02-29</span><br /><span>You can specify number of month with EOMONTH function also and it can be negative value</span><br /><span>SELECT EOMONTH ( Getdate(), -1 ) AS â€˜Last Monthâ€™</span><br /><span>Output: 2012-01-31</span><br /><strong><span>Â </span></strong><br /><strong><span>CHOOSE </span></strong><br /><span>Using this you can find out the specific item from a list of values.</span><br /><span>SELECT CHOOSE ( 4, â€˜CTOâ€™, â€˜GMâ€™, â€˜DGMâ€™, â€˜AGMâ€™, â€™Managerâ€™ )</span><br /><span>Output: AGM</span><br /><strong><span>Â </span></strong><br /><strong><span>CONCAT</span></strong><br /><span>This function is concatenating two or more string</span><br /><span>SELECT CONCAT( emp_name,â€™Joining Dateâ€™, joingdate)</span><br /><span>Output: Rahman Joining Date 01/12/2001</span><br /><strong><span>Â </span></strong><br /><strong><span>LAST_VALUE and FIRST_VALUE</span></strong><br /><span>Using the function you can last value among the set of ordered values according to specified ordered &amp; partitioned criteria. First value return the first value in an ordered set of values.</span><br /><span>Insert into result(Department ,ID ,Marks ) values (1,103,70), (1,104,58) (2,203,65) (2,201,85)</span><br /><span>Select Â Â Department,Id ,Marks, last_value(Marks) over (Partition by Department order By Marks) as</span><br /><span>â€˜Marks Sequenceâ€™ ,first_value (Marks) over (Partition by Department order By Marks) as â€˜First valueâ€™</span><br /><span>from result</span><br /><span>OutPut</span><br /><span>Department Â Â IdÂ Â Â Â Â Â Â  MarksÂ Â Â Â Â  Marks SequenceÂ Â Â Â Â  First valueâ€™</span><br /><span>1Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â  104Â Â Â Â Â Â  58Â Â Â Â Â Â Â Â Â Â Â  58Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  58</span><br /><span>1Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â  103Â Â Â Â Â Â  70Â Â Â Â Â Â Â Â Â Â Â  70Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  58</span><br /><span>2Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â  203Â Â Â Â Â Â Â  65Â Â Â Â Â Â Â Â Â Â Â  65Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  65</span><br /><span>2Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  201Â Â Â Â Â Â Â Â  85Â Â Â Â Â Â Â Â Â Â Â  85Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  65</span><br /><strong><span>Â </span></strong><br /><strong><span>LEAD</span></strong><br /><span>Using the function you can accesses data from a subsequent row in the same result set without the use of a self-join.</span><br /><span>SQL:</span><br /><span>SELECT BusinessEntityID, YEAR(QuotaDate) AS SalesYear, SalesQuota AS CurrentQuota,</span><br /><span>LEAD(SalesQuota, 1,0) OVER (ORDER BY YEAR(QuotaDate)) AS PreviousQuota</span><br /><span>FROM Sales.SalesPersonQuotaHistory</span><br /><span>WHERE BusinessEntityID = 275 and YEAR(QuotaDate) IN (â€˜2005â€™,â€™2006â€™);</span><br /><span>OutPut:</span><br /><span>BusinessEntityID SalesYearÂ Â  CurrentQuotaÂ Â Â Â Â Â Â Â Â  NextQuota</span><br /><span>â€”â€”â€”â€”â€”- â€”â€”â€”â€“ â€”â€”â€”â€”â€”â€”â€” â€”â€”â€”â€”â€”â€”â€”</span><br /><span>275Â Â Â Â Â Â Â Â Â Â Â Â Â  2005Â Â Â Â Â Â Â  367000.00Â Â Â Â Â Â Â Â Â Â Â Â  556000.00</span><br /><span>275Â Â Â Â Â Â Â Â Â Â Â Â Â  2005Â Â Â Â Â Â Â  556000.00Â Â Â Â Â Â Â Â Â Â Â Â  502000.00</span><br /><span>275Â Â Â Â Â Â Â Â Â Â Â Â Â  2006Â Â Â Â Â Â Â  502000.00Â Â Â Â Â Â Â Â Â Â Â Â  550000.00</span><br /><span>275Â Â Â Â Â Â Â Â Â Â Â Â Â  2006Â Â Â Â Â Â Â  550000.00Â Â Â Â Â Â Â Â Â Â Â Â  1429000.00</span><br /><span>275Â Â Â Â Â Â Â Â Â Â Â Â Â  2006Â Â Â Â Â Â Â  1429000.00Â Â Â Â Â Â Â Â Â Â Â  1324000.00</span><br /><span>275Â Â Â Â Â Â Â Â Â Â Â Â Â  2006Â Â Â Â Â Â Â  1324000.00Â Â Â Â Â Â Â Â Â Â Â  0.00</span><br /><strong><span>File Group Enhancement:</span></strong><br /><span>A FILESTREAM filegroup can contain more than one file. For a code example that demonstrates how to create a FILESTREAM filegroup that contains multiple files</span></p>
:ET